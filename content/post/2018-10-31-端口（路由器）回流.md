---
title: 端口（路由器）回流
author: ShadoWalker
type: post
date: 2018-10-31T14:19:51+00:00
url: /?p=323
categories:
  - 转载

---
在某次做端口映射的时候，发现在局域网内映射出去的公网地址无法访问，一番研究后发现在支持端口回流的路由器上配置端口映射并设置端口回流可以解决这个问题。当时就很好奇端口回流是个什么东西，不过好奇之余也没有深入研究。今天碰巧看到了这篇文章，原作者写的条例很清晰，内容也浅显易懂，遂转载收藏之。个人觉得原作者的排版和标点使用补水很清晰，所以稍微进行了一点修改。

转载自：https://blog.csdn.net/a595364628/article/details/51657345

&nbsp;

&nbsp;

<p style="text-align: center;">
  <strong>路由器回流简介</strong><br /> <strong>(端口映射特例）</strong>
</p>

**回流是什么？最简单的一个实例：**
  
网吧内网一台主机192.168.0.2建了个WEB服务站点端口80，然后在网关(其内网地址是192.168.0.1、公网地址为218.4.218.4)上映射80端口到192.168.0.2的80端口，这样INTERNET上就能以http://218.4.218.4:80的地址访问到192.168.0.2的WEB站点了。
  
然后出现了个问题，在同网吧的另一台电脑192.168.0.3上，键入http://218.4.218.4:80，却无法访问该WEB站点。
  
就这个现象，我们就称之为“不支持回流”了，这里指的是网关上的映射方式不支持回流，所以说“回流”一说，是针对映射方式而言的。
  
现在我们来看常规情况下，是为什么会发生这种情况的。
  
我以前对iptables特别感兴趣的时候，曾对这个问题非常迷惑不解，直到去年为了考试，学习网络基础的时候才搞明白这个事情。

**过程如下：**
  
192.168.0.3要请求访问218.4.218.4的80端口，根据它掌握的路由表，它本身是不知道电脑218.4.218.4在哪里的，所以把将这个数据包发送给它的默认路由，即电脑192.168.0.1。
  
注意：这个数据包的源地址是192.168.0.3、源端口假设是1025、目标地址是218.4.218.4、目标端口是80、SYN标志位为1、这是建立TCP连接的第一次握手。

如果“把目标地址为218.4.218.4的数据包发给了192.168.0.1”你听起来觉得有点矛盾，那么我解释一下：

其实这个数据包的目标IP地址是218.4.218.4，却是192.168.0.1的电脑192.168.0.1接收到了这份数据包(因为它的身份是路由器，所以允许接收和转发目标地址不是自已、MAC地址却是自已接口 MAC地址的数据包)，它分析这个数据包的目标地址，发现这个数据包是需要中转到电脑192.168.0.2:80去的，于是它把这个数据包转发给了电脑 192.168.0.2:80。

**注意：**这个数据包的源地址是192.168.0.3、源端口是1025、目标地址为192.168.0.2、目标端口为80、SYN标志位为1。我们要注意这个数据包在转发后发生了变化了，即**目标地址变了**。

电脑192.168.0.2顺利接到了数据包，它马上作出回应，发送一个数据包给电脑192.168.0.3。

**注意：**这个数据包的源地址是192.168.0.2、源端口是80、目标地址192.168.0.3、目标端口为1025、SYN标志位为1、ACK标志位为1、这是建立TCP连接的第二次握手。

电脑192.168.0.3顺利接到了数据包，然而它发现这是一个来自192.168.0.2:80的回应，因为ACK标志位值为1摆在那里呢。它想不起来什么时候给192.168.0.2:80这个目标对象发送过SYN请求，它认为这是一个错误的数据包，于是决定把这个数据包丢弃。然后继续等待 218.4.218.4:80的回应，一直等到超时。

而电脑192.168.0.2这边，它等192.168.0.3:1025的第三次握手请求包发送过来，以便建立一个TCP的连接。同样也没有结果，一直等到超时。三次握手在规定的时间内没有完成，访问宣布流产了。

&nbsp;

**那么怎么样才能正常访问呢？也就是说怎么样形成“回流”呢？**
  
玄机在于电脑192.168.0.1把第一次握手的那个数据包在转发时，**不仅要修改目标地址和端口，也要修改源地址和端口**，我们来看一下情况会有什么不同：
  
电脑192.168.0.1接收到了这份数据包(因为它的身份是路由器，所以允许接收和转发目标IP地址不是自已、MAC地址却是自已接口MAC地址的数据包)，它分析这个数据包的目标地址，发现这个数据包是需要中转到电脑192.168.0.2:80去的，于是它把这个数据包通过自已的5201端口转发给了电脑192.168.0.2:80，并在内存里面记录下来了，192.168.0.1:5201已定位给了192.168.0.3:1025。
  
**注意：**这个数据包的源地址是192.168.0.1、源端口是5201、目标地址为192.168.0.2、目标端口为80、SYN标志位为1。

电脑192.168.0.2顺利接到了数据包，它马上作出回应，发送一个数据包给电脑192.168.0.1。
  
**注意：**这个数据包的源地址是192.168.0.2、源端口是80、目标地址192.168.0.1、目标端口为5201、SYN标志位为1、ACK标志位为1、这是建立TCP连接的第二次握手。

电脑192.168.0.1顺利接到了数据包，检查内存记录发现，这个数据包真正的收货人是192.168.0.3:1025，于是它把这个数据包转发给192.168.0.3。
  
**注意：**这个数据包的的源地址是218.4.218.4、源端口为80、目标地址为192.168.0.3、目标端口为1025。我们要注意这个数据包在转发后发生变化了，即源地址变了。这很重要！为什么会变，因为在它心目当中，192.168.0.2:80早已定位给了218.4.218.4:80，映射规则使然。

电脑192.168.0.3顺利接到了数据包，发现期待已久的218.4.218.4:80终于有了回音，它兴奋不已的发出第三次的握手请求。
  
**注意：**这个数据包的源地址是192.168.0.3、源端口是1025、目标地址是218.4.218.4、目标端口是80、ACK标志位为1、这是建立TCP连接的第三次握手。

跟前面的数据包一样，这个数据包会从192.168.0.1那里中转给192.168.0.2。
  
以后192.168.0.2:80和192.168.0.3:1025之间来往通信的数据包，全部由192.168.0.1负责中转，“回流”构成了。